Multi Server Client Program

>In the basic model the server handles only one client at a time .The simple way to handle multiple clients would be to spawn a new thread for every new client connected to the server.

>Semaphores: Semaphore is simply a variable that is non-negative and shared between threads. This variable is used to solve the critical section problem and to achieve process synchronization in the multiprocessing environment.

Implementation:

For the server-side, create two different threads; a reader thread, and a writer thread. First, declare a serverSocket, an integer, a variable to hold the return of the socket function.

int serverSocket = socket(domain, type, protocol);
    serverSocket: Socket descriptor, an integer (like a file-handle).
    domain: Integer, communication domain e.g., AF_INET (IPv4 protocol), AF_INET6 (IPv6 protocol).
    type: Communication type.
    SOCK_STREAM: TCP(reliable, connection-oriented).
    SOCK_DGRAM: UDP(unreliable, connectionless).
    protocol: Protocol value for Internet Protocol(IP), which is 0. This is the same number that appears on the protocol field in the IP header of a packet.(man protocols for more details).
    
Then, after initializing all the necessary variables, bind the socket.

bind: After the creation of the socket, the bind function binds the socket to the address and port number specified in addr(custom data structure). In the example code, we bind the server to the local host, hence INADDR_ANY is used to specify the IP address.

int bind(int sockfd, const struct sockaddr *addr, 
         socklen_t addrlen);
         
listen: It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog defines the maximum length to which the queue of pending c

listen: It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.

int listen(int sockfd, int backlog);
For more connection functions used in this article, please refer to this article for socket programming listen: It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.

int listen(int sockfd, int backlog);
For more connection functions used in this article, please refer to this article for socket programming listen: It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.

int listen(int sockfd, int backlog);

 Approach:
After accepting the connection to the desired port, receive an integer from the client that defines the choice for reading or writing. Choice 1 indicates reader, while choice 2 indicates writer.
After successfully receiving data, call for pthread_create to create reader threads and writer threads.
After making successful connections to the server-client asks the user for input on the choice variable.
After getting the choice from the user, the client then sends this choice to the server to call the reader or writer thread by creating a client thread for the request.
 
 
